<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tile mutation</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #f8f8f8;

        }
        
        .container {
            max-width: 500px;
            width: 100%;
            padding: 20px;
        }
        
        h1 {
            font-size: 42px;
            margin-bottom: 15px;
            color: #ffd166;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            letter-spacing: 1px;
        }
        
        .game-container {
            background: rgba(25, 25, 35, 0.8);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            border: 1px solid #4a4a6a;
        }
        
        .game-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 70%);
            pointer-events: none;
        }
        
        .header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .score-container {
            width: 100%;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        
        .score-box {
            background: linear-gradient(145deg, #2d4059, #1d2d44);
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            min-width: 120px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 1px solid #4a5975;
        }
        
        .score-title {
            font-size: 14px;
            display: block;
            color: #a1b4cf;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .preview-container {
            background: rgba(35, 35, 55, 0.7);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            border: 1px solid #4a4a6a;
            position: relative;
            z-index: 5;
        }
        
        .preview-title {
            font-size: 18px;
            margin-bottom: 12px;
            color: #ffd166;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        
        .preview-content {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .preview-row {
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .preview-cell {
            width: 80px;
            height: 80px;
            background: rgba(70, 70, 90, 0.4);
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            font-weight: bold;
            color: #e0e0e0;
            position: relative;
            overflow: hidden;
        }
        
        .preview-cell.active {
            border: 2px solid #ffd166;
        }
        
        .timer {
            font-size: 18px;
            color: #ffd166;
            font-weight: bold;
        }
        
        .timer-bar {
            height: 10px;
            background: rgba(255, 209, 102, 0.2);
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .timer-progress {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ffd166, #ff9a76);
            transition: width 0.1s linear;
        }
        
        .grid-container {
            position: relative;
            height: 455px;
            overflow: hidden;
            margin-top: 20px;
        }
        
        .grid {
            background: #2d4059;
            border-radius: 8px;
            padding: 15px;
            position: absolute;
            bottom: 0;
            left: 15px;
            right: 15px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
            border: 1px solid #4a5975;
        }
        
        .grid-row {
            display: flex;
            margin-bottom: 15px;
        }
        
        .grid-row:last-child {
            margin-bottom: 0;
        }
        
        .grid-cell {
            width: 80px;
            height: 80px;
            margin-right: 15px;
            background: rgba(50, 60, 80, 0.6);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            font-weight: bold;
            color: #f0f0f0;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
        }
        
        .grid-cell:last-child {
            margin-right: 0;
        }
        
        .tile {
            position: absolute;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            font-weight: bold;
            border-radius: 5px;
            color: #f8f8f8;
            transition: all 0.2s ease;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        
        .tile-new {
            animation: appear 0.3s;
        }
        
        @keyframes appear {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .tile-2 { background: #4a5975; }
        .tile-4 { background: #3d4e6d; }
        .tile-8 { background: #2d4059; color: #ffd166; }
        .tile-16 { background: #1d2d44; color: #ffd166; }
        .tile-32 { background: #0d1d2d; color: #ff9a76; }
        .tile-64 { background: #0a1520; color: #ff9a76; }
        .tile-128 { background: #06121d; color: #ff7b54; font-size: 30px; }
        .tile-256 { background: #030d17; color: #ff7b54; font-size: 30px; }
        .tile-512 { background: #01080e; color: #ff5d30; font-size: 30px; }
        .tile-1024 { background: #000408; color: #ff5d30; font-size: 25px; }
        .tile-2048 { background: #000000; color: #ff3c00; font-size: 25px; box-shadow: 0 0 15px #ff5d30; }
        
        .falling {
            transition: transform 0.5s ease-in-out;
            /* cubic-bezier(0.34, 1.56, 0.64, 1) */
            z-index: 20;
            animation: fallBounce 0.5s;
        }
        
        @keyframes fallBounce {
            0% { transform: translateY(-100px); }
            60% { transform: translateY(10px); }
            80% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }
        
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 15, 30, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 8px;
            display: none;
            backdrop-filter: blur(3px);
        }
        
        .game-over-text {
            font-size: 48px;
            font-weight: bold;
            color: #ffd166;
            margin-bottom: 30px;
            text-shadow: 0 2px 10px rgba(255, 209, 102, 0.5);
        }
        
        .restart-button {
            background: linear-gradient(145deg, #ff9a76, #ff7b54);
            color: #1a1a2e;
            border: none;
            border-radius: 6px;
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(255, 123, 84, 0.3);
        }
        
        .restart-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(255, 123, 84, 0.5);
        }
        
        .controls {
            margin-top: 25px;
            color: #a1b4cf;
            font-size: 16px;
            padding: 10px;
            background: rgba(35, 35, 55, 0.5);
            border-radius: 8px;
        }
        
        .instructions {
            margin-top: 20px;
            color: #a1b4cf;
            font-size: 14px;
            line-height: 1.6;
            max-width: 460px;
            margin-left: auto;
            margin-right: auto;
            background: rgba(25, 25, 35, 0.6);
            padding: 15px;
            border-radius: 8px;
        }
        
        .instructions h3 {
            color: #ffd166;
            margin-bottom: 10px;
        }
        
        .instructions ul {
            text-align: left;
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .falling-area {
            position: absolute;
            top: 0;
            /* left: 0px; */
            /* right: 15px; */
            height: 30px;
            z-index: 1;
        }
        
        .falling-tile {
            position: absolute;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 35px;
            font-weight: bold;
            border-radius: 5px;
            color: #f8f8f8;
            z-index: 15;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transform: translateY(-50px);
        }
        
        @media (max-width: 500px) {
            .container{
                padding: 5px;
            }

            .grid-cell {
                width: 80px;
                height: 80px;
                margin-right: 10px;
                font-size: 30px;
            }
            
            .tile {
                width: 80px;
                height: 80px;
                font-size: 30px;
            }
            
            .falling-tile {
                width: 74px;
                height: 80px;
                font-size: 30px;
            }
            
            .preview-cell {
                width: 50px;
                height: 50px;
                font-size: 18px;
            }
            
            .score-box {
                min-width: 100px;
                padding: 10px 15px;
            }
            .score-container{
                padding: 10px;
            }
            
            .grid-container {
                height: 400px;
            }
            .grid{
                left: 0;
                right: 0;
            }
            .game-container{
                padding: 0px;
            }
            body{
                padding: 5px;
                transform: scale(0.9) translateY(-50px);
            }
            .falling-area {
            position: absolute;
            top: 0;
            height: 30px;
            z-index: 1;
        }
        }
    </style>
</head>
<body>
    <div class="container">

        
        <div class="game-container">
            <div class="header">
                <div class="score-container">
                    <div class="score-box">
                        <span class="score-title">Очки</span>
                        <span id="score">0</span>
                    </div>
                    <div class="score-box">
                        <span class="score-title">Рекорд</span>
                        <span id="best-score">0</span>
                    </div>
                </div>
            </div>
            
            <div class="game-area">
                <div class="preview-container">
                    <div class="preview-title">Следующие плитки:</div>
                    <div class="preview-content">
                        <div class="preview-row" id="preview-row">
                            <!-- Preview cells will be generated by JavaScript -->
                        </div>
                        <div class="timer">
                            <div id="timer-text">5.0</div>
                            <div class="timer-bar">
                                <div class="timer-progress" id="timer-progress"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="grid-container" id="grid-container">
                    <div class="falling-area" id="falling-area"></div>
                    <div class="grid" id="grid">
                        <!-- 4x4 grid will be generated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="game-over" id="game-over">
                <div class="game-over-text">Игра окончена!</div>
                <button class="restart-button" id="restart-button">Играть снова</button>
            </div>
        </div>
        
        <div class="instructions">
            <h3>Как играть:</h3>
            <ul>
                <li>Используйте стрелки на клавиатуре для перемещения плиток</li>
                <li>Плитки с одинаковыми числами сливаются при столкновении</li>
                <li>Сверху появляются новые плитки (как в тетрисе)</li>
                <li>Цель - получить плитку 2048</li>
                <li>В окне предпросмотра показаны следующие плитки и их позиции</li>
            </ul>
        </div>
    </div>
    
   <script>
    document.addEventListener('DOMContentLoaded', () => {
        const gridSize = 4;
        const grid = document.getElementById('grid');
        const previewRow = document.getElementById('preview-row');
        const scoreDisplay = document.getElementById('score');
        const bestScoreDisplay = document.getElementById('best-score');
        const gameOverDisplay = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const gridContainer = document.getElementById('grid-container');
        const fallingArea = document.getElementById('falling-area');
        const timerText = document.getElementById('timer-text');
        const timerProgress = document.getElementById('timer-progress');
        
        let board = [];
        let nextTiles = [];
        let score = 0;
        let bestScore = localStorage.getItem('bestScore') || 0;
        let isGameOver = false;
        let isMoving = false;
        let dropInterval;
        let dropTimer = 3;
        let dropTimerInterval;
        let lastDropTime = 0;
        let hasMoved = false; // Флаг для отслеживания движения
        
        bestScoreDisplay.textContent = bestScore;
        
        // Initialize the game
        function initGame() {
            // Clear the grid and preview
            grid.innerHTML = '';
            previewRow.innerHTML = '';
            fallingArea.innerHTML = '';
            
            // Create preview cells
            for (let i = 0; i < gridSize; i++) {
                const previewCell = document.createElement('div');
                previewCell.className = 'preview-cell';
                previewCell.id = `preview-cell-${i}`;
                previewRow.appendChild(previewCell);
            }
            
            // Create grid cells
            for (let row = 0; row < gridSize; row++) {
                board[row] = [];
                const gridRow = document.createElement('div');
                gridRow.className = 'grid-row';
                
                for (let col = 0; col < gridSize; col++) {
                    board[row][col] = null;
                    const gridCell = document.createElement('div');
                    gridCell.className = 'grid-cell';
                    gridCell.id = `cell-${row}-${col}`;
                    gridRow.appendChild(gridCell);
                }
                
                grid.appendChild(gridRow);
            }
            
            score = 0;
            scoreDisplay.textContent = score;
            isGameOver = false;
            gameOverDisplay.style.display = 'none';
            isMoving = false;
            dropTimer = 3;
            lastDropTime = Date.now();
            hasMoved = false;
            nextTiles = [];
            
            // Generate first next tiles
            generateNextTile();
            generateNextTile();
            updatePreview();
            
            // Add initial tiles
            addRandomTile();
            addRandomTile();
            
            // Start the falling tiles interval
            if (dropInterval) clearInterval(dropInterval);
            if (dropTimerInterval) clearInterval(dropTimerInterval);
            
            startDropTimer();
            scheduleNextDrop();
        }
        
        // Generate next falling tile
        function generateNextTile() {
            let column;
            let attempts = 0;
            const maxAttempts = 10;
            
            // Пытаемся найти столбец, который не совпадает с предыдущим в очереди
            do {
                column = Math.floor(Math.random() * gridSize);
                attempts++;
                
                // Если слишком много попыток, просто берем любой столбец
                if (attempts >= maxAttempts) break;
                
                // Проверяем, что предыдущая плитка не в том же столбце
            } while (nextTiles.length > 0 && nextTiles[nextTiles.length - 1].column === column);
            
            const value = Math.random() < 0.85 ? 2 : 4;
            nextTiles.push({ column, value });
            
            // Keep only 2 next tiles in queue
            if (nextTiles.length > 2) {
                nextTiles.shift();
            }
        }
        
        // Update the preview display
        function updatePreview() {
            // Clear all preview cells
            for (let i = 0; i < gridSize; i++) {
                const cell = document.getElementById(`preview-cell-${i}`);
                cell.innerHTML = '';
                cell.classList.remove('active');
            }
            
            // Show all upcoming tiles in preview
            nextTiles.forEach(tile => {
                const cell = document.getElementById(`preview-cell-${tile.column}`);
                if (cell) {
                    cell.classList.add('active');
                    const previewValue = document.createElement('div');
                    previewValue.className = `preview-value`;
                    previewValue.textContent = tile.value;
                    cell.appendChild(previewValue);
                }
            });
        }
        
        // Schedule next tile drop
        function scheduleNextDrop() {
            const now = Date.now();
            const timeSinceLastDrop = now - lastDropTime;
            const delay = Math.max(0, 5000 - timeSinceLastDrop);
            
            if (dropInterval) clearInterval(dropInterval);
            
            dropInterval = setTimeout(() => {
                if (!isGameOver && !isMoving) {
                    addFallingTileFromQueue();
                }
                lastDropTime = now;
                scheduleNextDrop();
            }, delay);
        }
        
        // Start drop timer countdown
        function startDropTimer() {
            dropTimer = 3;
            updateTimerDisplay();
            
            if (dropTimerInterval) clearInterval(dropTimerInterval);
            
            dropTimerInterval = setInterval(() => {
                const now = Date.now();
                const timeSinceLastDrop = now - lastDropTime;
                dropTimer = Math.max(0, (5000 - timeSinceLastDrop) / 1000);
                updateTimerDisplay();
            }, 50);
        }
        
        // Update timer display
        function updateTimerDisplay() {
            timerText.textContent = dropTimer.toFixed(1);
            timerProgress.style.width = `${(dropTimer / 5) * 100}%`;
        }
        
        // Add a random tile (2 or 4) to a random empty cell
        function addRandomTile() {
            const emptyCells = [];
            
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === null) {
                        emptyCells.push({ row, col });
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const value = Math.random() < 0.9 ? 2 : 4;
                
                addTile(row, col, value);
                return true;
            }
            
            return false;
        }
        
        // Add falling tile from queue
        function addFallingTileFromQueue() {
            if (isGameOver || nextTiles.length === 0 || isMoving) return;
            
            const nextTile = nextTiles.shift();
            addFallingTile(nextTile.column, nextTile.value);
            generateNextTile();
            updatePreview();
        }
        
        // Add a single falling tile to a column
        function addFallingTile(col, value) {
            // Create falling tile element
            const fallingTile = document.createElement('div');
            fallingTile.className = `falling-tile tile-${value}`;
            fallingTile.textContent = value;
            
            // Position the tile above the grid
            const cell = document.getElementById('cell-0-0');
            const cellRect = cell.getBoundingClientRect();
            const gridRect = gridContainer.getBoundingClientRect();
            
            const leftPos = cellRect.left - gridRect.left + col * (cellRect.width + 15);
            fallingTile.style.left = `${leftPos}px`;
            fallingTile.style.top = '0';
            
            fallingArea.appendChild(fallingTile);
            
            // Force reflow to ensure the initial position is applied
            fallingTile.getBoundingClientRect();
            
            // Find the landing row
            let landingRow = 0;
            while (landingRow < gridSize && board[landingRow][col] === null) {
                landingRow++;
            }
            
            // Calculate final position
            const finalTop = cellRect.top - gridRect.top + (landingRow > 0 ? landingRow - 1 : 0) * (cellRect.height + 15) - 15;
            
            // Animate the fall
            fallingTile.style.transition = 'transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1)';
            fallingTile.style.transform = `translateY(${finalTop}px)`;
            
            // Handle landing
            setTimeout(() => {
                if (landingRow === gridSize) {
                    landingRow = gridSize - 1;
                    board[landingRow][col] = value;
                    addTile(landingRow, col, value);
                    fallingTile.remove();
                    
                    // Check if top row is full after landing
                    checkTopRowFull();
                } else {
                    if (landingRow < gridSize && board[landingRow][col] === value) {
                        mergeTiles(landingRow, col, value);
                        fallingTile.remove();
                    } else {
                        if (landingRow > 0) {
                            landingRow--;
                            board[landingRow][col] = value;
                            addTile(landingRow, col, value);
                            fallingTile.remove();
                            
                            // Check if top row is full after landing
                            checkTopRowFull();
                        } else {
                            // Tile landed on top row and can't merge - game over
                            gameOver();
                            fallingTile.remove();
                            return;
                        }
                    }
                }
            }, 500);
        }
        
        // Check if top row is full
        function checkTopRowFull() {
            for (let col = 0; col < gridSize; col++) {
                if (board[0][col] === null) {
                    return false;
                }
            }
            gameOver();
            return true;
        }
        
        // Add a tile to the board
        function addTile(row, col, value) {
            board[row][col] = value;
            const tile = createTile(row, col, value);
            document.getElementById(`cell-${row}-${col}`).appendChild(tile);
        }
        
        // Create a tile element
        function createTile(row, col, value) {
            const tile = document.createElement('div');
            tile.className = `tile tile-${value} tile-new`;
            tile.id = `tile-${row}-${col}`;
            tile.textContent = value;
            return tile;
        }
        
        // Merge tiles
        function mergeTiles(row, col, value) {
            const newValue = value * 2;
            board[row][col] = newValue;
            
            // Update score
            score += newValue;
            scoreDisplay.textContent = score;
            if (score > bestScore) {
                bestScore = score;
                bestScoreDisplay.textContent = bestScore;
                localStorage.setItem('bestScore', bestScore);
            }
            
            // Update the tile
            const tileElement = document.getElementById(`tile-${row}-${col}`);
            if (tileElement) {
                tileElement.textContent = newValue;
                tileElement.className = `tile tile-${newValue}`;
                
                // Add merge animation
                tileElement.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    tileElement.style.transform = 'scale(1)';
                }, 100);
            } else {
                addTile(row, col, newValue);
            }
        }
        
        // Move tiles in a direction
        function move(direction) {
            if (isGameOver || isMoving) return;
            
            isMoving = true;
            let moved = false;
            const oldBoard = JSON.parse(JSON.stringify(board));
            
            if (direction === 'up') {
                for (let col = 0; col < gridSize; col++) {
                    let mergePosition = 0;
                    let previousValue = null;
                    
                    for (let row = 0; row < gridSize; row++) {
                        if (board[row][col] !== null) {
                            if (previousValue === board[row][col]) {
                                // Merge with previous tile
                                const mergedValue = previousValue * 2;
                                board[mergePosition - 1][col] = mergedValue;
                                board[row][col] = null;
                                score += mergedValue;
                                previousValue = null;
                                moved = true;
                            } else {
                                // Move tile to merge position
                                if (mergePosition !== row) {
                                    board[mergePosition][col] = board[row][col];
                                    board[row][col] = null;
                                    moved = true;
                                }
                                previousValue = board[mergePosition][col];
                                mergePosition++;
                            }
                        }
                    }
                }
            } else if (direction === 'down') {
                for (let col = 0; col < gridSize; col++) {
                    let mergePosition = gridSize - 1;
                    let previousValue = null;
                    
                    for (let row = gridSize - 1; row >= 0; row--) {
                        if (board[row][col] !== null) {
                            if (previousValue === board[row][col]) {
                                // Merge with previous tile
                                const mergedValue = previousValue * 2;
                                board[mergePosition + 1][col] = mergedValue;
                                board[row][col] = null;
                                score += mergedValue;
                                previousValue = null;
                                moved = true;
                            } else {
                                // Move tile to merge position
                                if (mergePosition !== row) {
                                    board[mergePosition][col] = board[row][col];
                                    board[row][col] = null;
                                    moved = true;
                                }
                                previousValue = board[mergePosition][col];
                                mergePosition--;
                            }
                        }
                    }
                }
            } else if (direction === 'left') {
                for (let row = 0; row < gridSize; row++) {
                    let mergePosition = 0;
                    let previousValue = null;
                    
                    for (let col = 0; col < gridSize; col++) {
                        if (board[row][col] !== null) {
                            if (previousValue === board[row][col]) {
                                // Merge with previous tile
                                const mergedValue = previousValue * 2;
                                board[row][mergePosition - 1] = mergedValue;
                                board[row][col] = null;
                                score += mergedValue;
                                previousValue = null;
                                moved = true;
                            } else {
                                // Move tile to merge position
                                if (mergePosition !== col) {
                                    board[row][mergePosition] = board[row][col];
                                    board[row][col] = null;
                                    moved = true;
                                }
                                previousValue = board[row][mergePosition];
                                mergePosition++;
                            }
                        }
                    }
                }
            } else if (direction === 'right') {
                for (let row = 0; row < gridSize; row++) {
                    let mergePosition = gridSize - 1;
                    let previousValue = null;
                    
                    for (let col = gridSize - 1; col >= 0; col--) {
                        if (board[row][col] !== null) {
                            if (previousValue === board[row][col]) {
                                // Merge with previous tile
                                const mergedValue = previousValue * 2;
                                board[row][mergePosition + 1] = mergedValue;
                                board[row][col] = null;
                                score += mergedValue;
                                previousValue = null;
                                moved = true;
                            } else {
                                // Move tile to merge position
                                if (mergePosition !== col) {
                                    board[row][mergePosition] = board[row][col];
                                    board[row][col] = null;
                                    moved = true;
                                }
                                previousValue = board[row][mergePosition];
                                mergePosition--;
                            }
                        }
                    }
                }
            }
            
            if (moved) {
                hasMoved = true;
                
                // Update score display
                scoreDisplay.textContent = score;
                if (score > bestScore) {
                    bestScore = score;
                    bestScoreDisplay.textContent = bestScore;
                    localStorage.setItem('bestScore', bestScore);
                }
                
                // Update the view
                updateBoardView();
                
                setTimeout(() => {
                    // Don't add random tiles after move
                    checkGameOver();
                    isMoving = false;
                }, 100);
            } else {
                isMoving = false;
            }
        }
        
        // Update the board view after moves
        function updateBoardView() {
            // Clear all tiles
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                if (!tile.classList.contains('falling-tile')) {
                    tile.remove();
                }
            });
            
            // Add all tiles back
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] !== null) {
                        addTile(row, col, board[row][col]);
                    }
                }
            }
        }
        
        // Check if game is over
        function checkGameOver() {
            // Check if there are empty cells
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (board[row][col] === null) {
                        return false;
                    }
                }
            }
            
            // Check if any moves are possible
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const value = board[row][col];
                    
                    // Check adjacent tiles
                    if (row > 0 && board[row - 1][col] === value) return false;
                    if (row < gridSize - 1 && board[row + 1][col] === value) return false;
                    if (col > 0 && board[row][col - 1] === value) return false;
                    if (col < gridSize - 1 && board[row][col + 1] === value) return false;
                }
            }
            
            // Game over
            gameOver();
            return true;
        }
        
        // Game over function
        function gameOver() {
            if (isGameOver) return;
            
            isGameOver = true;
            gameOverDisplay.style.display = 'flex';
            clearInterval(dropInterval);
            clearInterval(dropTimerInterval);
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            
            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    move('up');
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    move('down');
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    move('left');
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    move('right');
                    break;
            }
        });
        
        restartButton.addEventListener('click', initGame);
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        
        gridContainer.addEventListener('touchstart', (e) => {
            if (isGameOver) return;
            
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });
        
        gridContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        gridContainer.addEventListener('touchend', (e) => {
            if (isGameOver || !touchStartX || !touchStartY) return;
            
            touchEndX = e.changedTouches[0].clientX;
            touchEndY = e.changedTouches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            
            if (Math.max(absDx, absDy) < 30) return; // Ignore small movements
            
            if (absDx > absDy) {
                if (dx > 0) {
                    move('right');
                } else {
                    move('left');
                }
            } else {
                if (dy > 0) {
                    move('down');
                } else {
                    move('up');
                }
            }
            
            touchStartX = 0;
            touchStartY = 0;
            e.preventDefault();
        }, { passive: false });
        
        // Initialize the game
        initGame();
    });
</script>
</body>
</html>